#!/usr/bin/perl
# ---   *   ---   *   ---
# KEYMAP
# generates tables for
# key lookups, and such

# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit

# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

# deps
  use strict;
  use warnings;

  # change to install dir when we're done
  use lib $ENV{'ARPATH'}.'/avtomat/';
  use avt;

# ---   *   ---   *   ---
# some macros

  use constant {
    STRUCT => "CE",

  };use constant {
    CURSOR => "${ \STRUCT }.cursor",
    KBD    => "${ \STRUCT }.kbd",
    WDIM   => "${ \STRUCT }.wsz.ws_",
    BUSY   => "${ \STRUCT }.evcnt",
    CTTY   => "${ \STRUCT }.ctty",

  };use constant {
    CY     => "${ \CURSOR }.y",
    CYMN   => '0',
    CYMX   => "${ \WDIM }row-1",

    CX     => "${ \CURSOR }.x",
    CXMN   => '0',
    CXMX   => "${ \WDIM }col-1",

  };

# ---   *   ---   *   ---
# global storage

  my %CACHE=(
    -LAYOUT   => 0,
    -LAYOUT_I => 0,

  );

# ---   *   ---   *   ---

# magic
sub parse_kbdlay {
  my $f=$ENV{'ARPATH'}.'/ce/kbdlay';
  my @lines=split "\n",`cat $f`;
  my %kbdlay;my $i=0;
  my @layi=();

  while(@lines) {
    my $line=shift @lines;
    if(!$line || (index $line,'#')==0) {
      next;

    };$line.=($line eq 'NON')
      ? "$i"
      : ''
      ;

    $kbdlay{$line}=$i;$i++;
    push @layi,$line;

  };$CACHE{-LAYOUT_I}=\@layi;
  return \%kbdlay;

};$CACHE{-LAYOUT}=parse_kbdlay();

# arg=keyname
# Key Index, a simple shorthand
sub KI {
  my $key_name=shift;
  return $CACHE{-LAYOUT}->{$key_name};

};

# ---   *   ---   *   ---
# base table

  # 'key_name'=>[scancode,onDown,onUp,onHeld]

  my @KEYMAP=(

    # quick exit for testing
    'ESC' ,[KI('escape'),'','exit(0);','',],

    # modifiers
    'LALT',[KI('LAlt'),'','',''],

    # movement keys
    'AUP' ,[KI('up'),'','',
      CY.'-='.CY.'>('.CYMN.');',

    ],

    'ADWN',[KI('down'),'','',
      CY.'+='.CY.'<('.CYMX.');',

    ],

    'ARGT',[KI('right'),
    'if(IS_HEL(K_LALT)) {'.
    KBD.'[K_ARGT]&=~0b111;swtty(1,'.CTTY.');}',

    '',
    CX.'+='.CX.'<('.CXMX.');',

    ],

    'ALFT',[KI('left'),
    'if(IS_HEL(K_LALT)) {'.
    KBD.'[K_ALFT]&=~0b111;swtty(-1,'.CTTY.');}',
    '',

    CX.'-='.CX.'>('.CXMN.');',

    ],

#    # re/av,beg/end
#    'GPRV',[KI("re"),undef,CY.'='.CYMN],
#
#    'GNXT',[KI("av"),undef,CY.'='.CYMX],
#
#    'GBEG',[KI("home"),undef,CX.'='.CXMN],
#
#    'GEND',[KI("end"),undef,CX.'='.CXMX],
#
#    # del, ret
#    'EDEL',[KI("del"),undef,''],
#
#    'ERET',[KI("ret"),undef,''],

  );

# ---   *   ---   *   ---

sub generator {
  my $FH=shift;

  my $macros=''.

    "#ifndef NIHIL_FUNC\n".
    "#define NIHIL_FUNC\n".
    "typedef void(*nihil)(void);\n".
    "#endif\n".

    "#define IS_TAP(x) ((".KBD."[(x)]&0b001)>>0)\n".
    "#define IS_HEL(x) ((".KBD."[(x)]&0b010)>>1)\n".
    "#define IS_REL(x) ((".KBD."[(x)]&0b100)>>2)\n".

    "\n";

  my $utilfuncs=''.

    'void kbdcl(void) {'."\n".
    ' memset('.KBD.",\n".
    ' 0,sizeof('.KBD.')/sizeof('.KBD.'[0]));'."\n".
    "};\n";

  my @lists=();{

    my $item;

    # KEYMAP[key_name]==scancode
    # we don't use this, nice to have maybe?
    $item=avt::clist([0,'arr:char','KEYMAP','']);

    push @lists,$item;

    $item=avt::clist([0,'enum:K_COUNT','','']);
    push @lists,$item;

# ---   *   ---   *   ---

    # function pointer tables

    $item=avt::clist(
      [0,'arr:nihil','K_TAP_FUNCS','']

    );$item->[2]='keyskip';$item=avt::clist($item);
    push @lists,$item;

    $item=avt::clist(
      [0,'arr:nihil','K_HEL_FUNCS','']

    );$item->[2]='keyskip';$item=avt::clist($item);
    push @lists,$item;

    $item=avt::clist(
      [0,'arr:nihil','K_REL_FUNCS','']

    );$item->[2]='keyskip';$item=avt::clist($item);
    push @lists,$item;

  };

# ---   *   ---   *   ---
# layout -> keymap lookup table

  my $CODE_TO_KEY='';{

    # get (used_indices:used_values)
    my @used_keys=();{
      for(my $i=1;$i<@KEYMAP;$i+=2) {
        push @used_keys,$KEYMAP[$i]->[0];

      };
    };my $list=avt::clist(
      [0,'arr:char','KEYLAY','']

    );

# ---   *   ---   *   ---

    # match layout indices to used ones
    my @lay=@{ $CACHE{-LAYOUT_I} };
    my $i=0;while(@lay) {
      my $kname=shift @lay;
      my $kcode=KI($kname);

      $list->[2]=0;

      # cant think of a smart way to do it
      for(my $j=0;$j<@used_keys;$j++) {
        if($used_keys[$j]==$kcode) {
          $list->[2]=$j+1;last;

        };
      };

      $list=avt::clist($list);

    };$list->[0]++;

    $list=avt::clist($list);
    $CODE_TO_KEY=$list->[3];

  };

# ---   *   ---   *   ---

  # keydown events
  my $KEYSET="void keyset(char key,char rel) {\n";
  $KEYSET.=
    " char x=KEYLAY[key];\n".
    " if(!x) {return;};x--;\n".

    " if(!rel) {\n".

    "  ".KBD."[x]&=~1;\n".
    "  ".KBD."[x]|=1*(!IS_HEL(x));\n".

    "  K_TAP_FUNCS[(x+1)*IS_TAP(x)]();\n".

    "  return;\n\n";

# ---   *   ---   *   ---

  # keyup events
  $KEYSET.=" } else {\n".

    "   ".KBD."[x]&=~3;\n".
    "   ".KBD."[x]|=4;\n".

    "  K_REL_FUNCS[x+1]();\n".

    " };\n};\n\n";

# ---   *   ---   *   ---

  # event functions
  my $evfuncs=avt::cfunc(
    ['void:void','keyskip',';','']

  );

# ---   *   ---   *   ---

  # iter through the map
  my $i=0;while(@KEYMAP) {
    my $name=shift @KEYMAP;
    my $data=shift @KEYMAP;

    # unpack array reference
    my (
      $kcode,
      $onDown,
      $onUp,
      $onHeld,

    )=@{ $data };

# ---   *   ---   *   ---

    # populate lists
    { my $tap=($onDown)
        ? "K_TAP_FUNC_$name"
        : "keyskip";

      my $hel=($onHeld)
        ? "K_HEL_FUNC_$name"
        : "keyskip";

      my $rel=($onUp)
        ? "K_REL_FUNC_$name"
        : "keyskip";

      my @items=($kcode,"K_$name",$tap,$hel,$rel);
      for(my $j=0;$j<@lists;$j++) {
        $lists[$j]->[2]=$items[$j];
        $lists[$j]=avt::clist($lists[$j]);

      };

    };

# ---   *   ---   *   ---

    # make definitions
    { my @helper=(
        $onDown,'TAP',
        $onHeld,'HEL',
        $onUp  ,'REL',

      );while(@helper) {
        my $code=shift @helper;
        my $suff=shift @helper;

        if(!$code) {next;};

        $evfuncs->[1]="K_$suff"."_FUNC_$name";
        $evfuncs->[2]=$code;

        $evfuncs=avt::cfunc($evfuncs);

      };
    };

    $i++;

  };

# ---   *   ---   *   ---

  my $result=$CODE_TO_KEY.$macros.$utilfuncs;

  # close lists
  for(my $j=0;$j<2;$j++) {
    $lists[$j]->[0]++;
    $lists[$j]=avt::clist($lists[$j]);

    $result.=$lists[$j]->[3];

  };$result.=( $evfuncs->[3] );

  for(my $j=2;$j<@lists;$j++) {
    $lists[$j]->[0]++;
    $lists[$j]=avt::clist($lists[$j]);

    $result.=$lists[$j]->[3];

  };

# ---   *   ---   *   ---

  # ^add caller def
  $result.= $KEYSET.

    "void keychk(void) {\n".
    " ".BUSY."^=".BUSY.";\n".

    " for(int x=0;x<K_COUNT;x++) {\n".
    "  K_HEL_FUNCS[(x+1)*IS_HEL(x)]();\n".

    "  ".BUSY."+=(".KBD."[x]&0b111)!=0;\n".

    "  ".KBD."[x]|=2*IS_TAP(x);\n".
    "  ".KBD."[x]&=~1;\n".
    "  ".KBD."[x]&=~4;\n".

    " };\n".
    "};\n\n"

  ;

# ---   *   ---   *   ---

  # this bit is just to see the key names
  my $DEBUG_NAMES="static const char* KEY_NAMES[]={\n";
  my @lay=@{ $CACHE{-LAYOUT_I} };

  # make an array of human-readable ids
  # useful for debug prints
  while(@lay) {
    my $name=shift @lay;
    $DEBUG_NAMES.=(avt::dqwrap $name ).",\n";

  };$DEBUG_NAMES=substr(
      $DEBUG_NAMES,0,
      length $DEBUG_NAMES

  );$DEBUG_NAMES.="\n};\n\n";

  # write it all to file
  print $FH $result.$DEBUG_NAMES;

};

# ---   *   ---   *   ---

my $root=avt::root $ENV{'ARPATH'};chdir $root;

avt::wrcboil_h(
  '/ce/',
  'keymap',
  \&generator,
  'IBN-3DILA'

);


# ---   *   ---   *   ---
1; # ret
