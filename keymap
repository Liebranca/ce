#!/usr/bin/perl
# ---   *   ---   *   ---
# KEYMAP
# generates tables for
# key lookups, and such

# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit

# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

# deps
  use strict;
  use warnings;

  # change to install dir when we're done
  use lib $ENV{'ARPATH'}.'/avtomat/';
  use avt;

  my $root=avt::root $ENV{'ARPATH'};chdir $root;

# ---   *   ---   *   ---
# some macros

  use constant {
    STRUCT => "CE",

  };use constant {
    CURSOR => "${ \STRUCT }.cursor",
    KBD    => "${ \STRUCT }.kbd",
    WDIM   => "${ \STRUCT }.wsz.ws_",
    BUSY   => "${ \STRUCT }.evcnt",
    EVSTK  => "${ \STRUCT }.evstack",
    EVCNT  => "${ \STRUCT }.evstack_i",
    CTTY   => "${ \STRUCT }.ctty",

  };use constant {
    CY     => "${ \CURSOR }.y",
    CYMN   => '0',
    CYMX   => "${ \WDIM }row-1",

    CX     => "${ \CURSOR }.x",
    CXMN   => '0',
    CXMX   => "${ \WDIM }col-1",

  };

# ---   *   ---   *   ---
# global storage

  my %CACHE=(
    -LAYOUT   => 0,
    -LAYOUT_I => 0,

  );

# ---   *   ---   *   ---

# magic
sub parse_kbdlay {
  my $f=$ENV{'ARPATH'}.'/ce/kbdlay';
  my @lines=split "\n",`cat $f`;
  my %kbdlay;my $i=0;
  my @layi=();

  while(@lines) {
    my $line=shift @lines;
    if(!$line || (index $line,'#')==0) {
      next;

    };$line.=($line eq 'NON')
      ? "$i"
      : ''
      ;

    $kbdlay{$line}=$i;$i++;
    push @layi,$line;

  };$CACHE{-LAYOUT_I}=\@layi;
  return \%kbdlay;

};$CACHE{-LAYOUT}=parse_kbdlay();

# arg=keyname
# Key Index, a simple shorthand
sub KI {
  my $key_name=shift;
  return $CACHE{-LAYOUT}->{$key_name};

};

# ---   *   ---   *   ---

# parse *.k file into a list
sub rdkfile {

  my $fpath=shift;
  if(!(-e $fpath)) {
    print "Can't find $fpath";
    exit;

  };my $s=`cat $fpath`;
  my $tap=(split "onTap\n",$s)[1];
  $tap=(split "onHel\n",$tap)[0];

  my $hel=(split "onHel\n",$s)[1];
  $hel=(split "onRel\n",$hel)[0];

  my $rel=(split "onRel\n",$s)[1];

  for my $ev ($tap,$hel,$rel) {
    if((index $ev,'None')>-1) {$ev='';};
  };

  return ($tap,$rel,$hel);

};

# ---   *   ---   *   ---
# read glyph table

sub tifunc {
  my ($lc,$uc,$mr)=@_;
  for my $c($lc,$uc,$mr) {
    $c=sprintf "\\x%02X",ord($c);

  };

  my $s=<<"EOF"

  CE.evlinger+=8;CE.evlinger&=0xF;
  char table[4]="$lc$uc$mr";
  CE.ti=table[
    (IS_HEL(K_LSHIFT))
   +(IS_HEL(K_RALT)<<1)

  ];

EOF
; return $s;

};

sub rdti {

  my @table=split "\n",`cat ./ce/keys/ti`;
  my @map=();

  while(@table) {
    my $line=shift @table;
    if(!$line) {next;};

    my (
      $name,
      $lc,$uc,$mr

    )=split ' ',$line;

    my $fullname='TI'.( uc $name );
    if($name eq 'space') {
      $lc=$uc=$mr=' ';

    };

    my $onDown=tifunc($lc,$uc,$mr);

    push @map,$fullname;
    push @map,[KI($name),
      $onDown,'',''

    ]; #'K_TAP_FUNC_'.$fullname.'();'

  };return @map;

};

# ---   *   ---   *   ---
# base table

  # 'key_name'=>[scancode,onDown,onUp,onHeld]

  my @KEYMAP=(

    # quick exit for testing
    'ESC' ,[KI('escape'),'','exit(0);','',],

    # modifiers
    'LALT',[KI('LAlt'),'','',''],
    'RALT',[KI('RAlt'),'','',''],
    'LSHIFT',[KI('LShift'),'','',''],

    # movement keys
    'AUP' ,[
      KI('up'),
      rdkfile('./ce/keys/up.k')

    ],

    'ADWN',[
      KI('down'),
      rdkfile('./ce/keys/down.k')

    ],

    'ARGT',[
      KI('right'),
      rdkfile('./ce/keys/right.k')

    ],

    'ALFT',[
      KI('left'),
      rdkfile('./ce/keys/left.k')

    ],

#    # re/av,beg/end
#    'GPRV',[KI("re"),undef,CY.'='.CYMN],
#
#    'GNXT',[KI("av"),undef,CY.'='.CYMX],
#
#    'GBEG',[KI("home"),undef,CX.'='.CXMN],
#
#    'GEND',[KI("end"),undef,CX.'='.CXMX],
#
#    # del, ret
#    'EDEL',[KI("del"),undef,''],
#
#    'ERET',[KI("ret"),undef,''],

  );my $NON_TI=int((@KEYMAP)/2);
  push @KEYMAP,rdti;

# ---   *   ---   *   ---

sub generator {
  my $FH=shift;

  my $macros=''.

    "#ifndef NIHIL_FUNC\n".
    "#define NIHIL_FUNC\n".
    "typedef void(*nihil)(void);\n".
    "#endif\n".

    "#define IS_TAP(x) ((".KBD."[(x)]&0b001)>>0)\n".
    "#define IS_HEL(x) ((".KBD."[(x)]&0b010)>>1)\n".
    "#define IS_REL(x) ((".KBD."[(x)]&0b100)>>2)\n".

    "\n";

  my $utilfuncs=''.

    'void kbdcl(void) {'."\n".
    ' memset('.KBD.",\n".
    ' 0,sizeof('.KBD.')/sizeof('.KBD.'[0]));'."\n".
    "};\n";

  my @lists=();{

    my $item;

    # KEYMAP[key_name]==scancode
    # we don't use this, nice to have maybe?
    $item=avt::clist([0,'arr:char','KEYMAP','']);

    push @lists,$item;

    $item=avt::clist([0,'enum:K_COUNT','','']);
    push @lists,$item;

# ---   *   ---   *   ---

    # function pointer tables

    $item=avt::clist(
      [0,'arr:nihil','K_TAP_FUNCS','']

    );$item->[2]='keyskip';$item=avt::clist($item);
    push @lists,$item;

    $item=avt::clist(
      [0,'arr:nihil','K_HEL_FUNCS','']

    );$item->[2]='keyskip';$item=avt::clist($item);
    push @lists,$item;

    $item=avt::clist(
      [0,'arr:nihil','K_REL_FUNCS','']

    );$item->[2]='keyskip';$item=avt::clist($item);
    push @lists,$item;

  };

# ---   *   ---   *   ---
# layout -> keymap lookup table

  my $CODE_TO_KEY='';{

    # get (used_indices:used_values)
    my @used_keys=();{
      for(my $i=1;$i<@KEYMAP;$i+=2) {
        push @used_keys,$KEYMAP[$i]->[0];

      };
    };my $list=avt::clist(
      [0,'arr:char','KEYLAY','']

    );

# ---   *   ---   *   ---

    # match layout indices to used ones
    my @lay=@{ $CACHE{-LAYOUT_I} };
    my $i=0;while(@lay) {
      my $kname=shift @lay;
      my $kcode=KI($kname);

      $list->[2]=0;

      # cant think of a smart way to do it
      for(my $j=0;$j<@used_keys;$j++) {
        if($used_keys[$j]==$kcode) {
          $list->[2]=$j+1;last;

        };
      };

      $list=avt::clist($list);

    };$list->[0]++;

    $list=avt::clist($list);
    $CODE_TO_KEY=$list->[3];

  };

# ---   *   ---   *   ---

  my $EVSTACK=<<'EOF'

void evpop(char key) {
  char idex=0;
  for(char x=0;x<CE.evstack_i;x++) {
    if(CE.evstack[x]==key) {
      idex=x;
      break;

    };
  };CE.evstack[idex]=0x00;

  while(idex<CE.evstack_i) {
    CE.evstack[idex]=CE.evstack[idex+1];
    idex++;

  };CE.evstack_i--;
};

void evpush(char key) {
  char do_push=1;
  for(char x=0;x<CE.evstack_i;x++) {
    if(CE.evstack[x]==key) {
      do_push=0;
      break;

    };
  };if(do_push) {
    CE.evstack[CE.evstack_i]=key;
    CE.evstack_i++;

  };
};

EOF
;

# ---   *   ---   *   ---

  # keydown events
  my $KEYSET="void keyset(char key,char rel) {\n";
  $KEYSET.=
    " char x=KEYLAY[key];\n".
    " if(!x) {return;};x--;\n".

    " if(!rel) {\n".

    "  ".KBD."[x]&=~1;\n".
    "  ".KBD."[x]|=(1*(!IS_HEL(x))|(x>=$NON_TI));\n".

    "  K_TAP_FUNCS[(x+1)*IS_TAP(x)]();\n".
    "  evpush(x);\n";

# ---   *   ---   *   ---

  # keyup events
  $KEYSET.=" } else {\n".

    "  ".KBD."[x]&=~(0xFF03);\n".
    "  ".KBD."[x]|=4;\n".

    "  K_REL_FUNCS[x+1]();\n".
    "  evpop(x);\n".

    " };\n\n};\n\n";

# ---   *   ---   *   ---

  # event functions
  my $evfuncs=avt::cfunc(
    ['void:void','keyskip',';','']

  );

# ---   *   ---   *   ---

  # iter through the map
  my $i=0;while(@KEYMAP) {
    my $name=shift @KEYMAP;
    my $data=shift @KEYMAP;

    # unpack array reference
    my (
      $kcode,
      $onDown,
      $onUp,
      $onHeld,

    )=@{ $data };

# ---   *   ---   *   ---

    # populate lists
    { my $tap=($onDown)
        ? "K_TAP_FUNC_$name"
        : "keyskip";

      my $hel=($onHeld)
        ? "K_HEL_FUNC_$name"
        : "keyskip";

      my $rel=($onUp)
        ? "K_REL_FUNC_$name"
        : "keyskip";

      my @items=($kcode,"K_$name",$tap,$hel,$rel);
      for(my $j=0;$j<@lists;$j++) {
        $lists[$j]->[2]=$items[$j];
        $lists[$j]=avt::clist($lists[$j]);

      };

    };

# ---   *   ---   *   ---

    # make definitions
    { my @helper=(
        $onDown,'TAP',
        $onHeld,'HEL',
        $onUp  ,'REL',

      );while(@helper) {
        my $code=shift @helper;
        my $suff=shift @helper;

        if(!$code) {next;};

        $evfuncs->[1]="K_$suff"."_FUNC_$name";
        $evfuncs->[2]=$code;

        $evfuncs=avt::cfunc($evfuncs);

      };
    };

    $i++;

  };

# ---   *   ---   *   ---

  my $result=$CODE_TO_KEY.$macros.$utilfuncs;

  # close lists
  for(my $j=0;$j<2;$j++) {
    $lists[$j]->[0]++;
    $lists[$j]=avt::clist($lists[$j]);

    $result.=$lists[$j]->[3];

  };$result.=( $evfuncs->[3] );

  for(my $j=2;$j<@lists;$j++) {
    $lists[$j]->[0]++;
    $lists[$j]=avt::clist($lists[$j]);

    $result.=$lists[$j]->[3];

  };

# ---   *   ---   *   ---

  # ^add caller def
  $result.= $EVSTACK.$KEYSET.

    "void keychk(void) {\n".
    " ".EVSTK.'['.EVCNT."]=0x00;\n".
    " ".BUSY."^=".BUSY.";\n".

    ' char* ev='.EVSTK."+0;\n".
    " int repeat=0;\n".

    " while(*ev) {\n".
    "  char x=*ev;\n".

    "  int ind_repeat=(".KBD."[x]&0xFF00)>>8;".
    "  ".KBD."[x]+=(1*(ind_repeat<4))<<8;".

    "  repeat=(repeat!=0) || (ind_repeat==4);\n".

    "  K_HEL_FUNCS[(x+1)*IS_HEL(x)*repeat]();\n".

    "  ".BUSY."+=(".KBD."[x]&0b111)!=0;\n".

    "  ".KBD."[x]|=2*IS_TAP(x);\n".
    "  ".KBD."[x]&=~1;\n".
    "  ".KBD."[x]&=~4;\n".

    "  ev++;\n".

    " };\n".
    "};\n\n"

  ;

# ---   *   ---   *   ---

  # this bit is just to see the key names
  my $DEBUG_NAMES="static const char* KEY_NAMES[]={\n";
  my @lay=@{ $CACHE{-LAYOUT_I} };

  # make an array of human-readable ids
  # useful for debug prints
  while(@lay) {
    my $name=shift @lay;
    $DEBUG_NAMES.=(avt::dqwrap $name ).",\n";

  };$DEBUG_NAMES=substr(
      $DEBUG_NAMES,0,
      length $DEBUG_NAMES

  );$DEBUG_NAMES.="\n};\n\n";

  # write it all to file
  print $FH $result.$DEBUG_NAMES;

};

# ---   *   ---   *   ---

avt::wrcboil_h(
  '/ce/',
  'keymap',
  \&generator,
  'IBN-3DILA'

);


# ---   *   ---   *   ---
1; # ret
