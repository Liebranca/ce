#!/usr/bin/perl
# ---   *   ---   *   ---
# KEYMAP
# generates tables for
# key lookups, and such

# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit

# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

# deps
  use strict;
  use warnings;

  # change to install dir when we're done
  use lib $ENV{'ARPATH'}.'/avtomat/';
  use avt;

# ---   *   ---   *   ---
# some macros

  use constant {
    STRUCT => "CE",

  };use constant {
    CURSOR => "${ \STRUCT }.cursor",
    KBD    => "${ \STRUCT }.kbd",
    WDIM   => "${ \STRUCT }.wsz.ws_",

  };use constant {
    CY     => "${ \CURSOR }.y",
    CYMN   => '0',
    CYMX   => "${ \WDIM }row-1",

    CX     => "${ \CURSOR }.x",
    CXMN   => '0',
    CXMX   => "${ \WDIM }col-1",

  };

# ---   *   ---   *   ---
# global storage

  my %CACHE=(
    -LAYOUT   => 0,
    -LAYOUT_I => 0,

  );

# ---   *   ---   *   ---

# magic
sub parse_kbdlay {
  my $f=$ENV{'ARPATH'}.'/ce/kbdlay';
  my @lines=split "\n",`cat $f`;
  my %kbdlay;my $i=0;
  my @layi=();

  while(@lines) {
    my $line=shift @lines;
    if(!$line || (index $line,'#')==0) {
      next;

    };$line.=($line eq 'NON')
      ? "$i"
      : ''
      ;

    $kbdlay{$line}=$i;$i++;
    push @layi,$line;

  };$CACHE{-LAYOUT_I}=\@layi;
  return \%kbdlay;

};$CACHE{-LAYOUT}=parse_kbdlay();

# arg=keyname
# Key Index, a simple shorthand
sub KI {
  my $key_name=shift;
  return $CACHE{-LAYOUT}->{$key_name};

};

# ---   *   ---   *   ---
# base table

  # 'key_name'=>[scancode,onDown,onUp,onHeld]

  my @KEYMAP=(

    # movement keys
    'GFWD',[KI('up'),'','',
      CY.'-='.CY.'>('.CYMN.')',

    ],

    'GBAK',[KI('down'),'','',
      CY.'+='.CY.'<('.CYMX.')',

    ],

    'GRGT',[KI('right'),'','',
      CX.'+='.CX.'<('.CXMX.')',

    ],

    'GLFT',[KI('left'),'','',
      CX.'-='.CX.'>('.CXMN.')',

    ],

#    # re/av,beg/end
#    'GPRV',[KI("re"),undef,CY.'='.CYMN],
#
#    'GNXT',[KI("av"),undef,CY.'='.CYMX],
#
#    'GBEG',[KI("home"),undef,CX.'='.CXMN],
#
#    'GEND',[KI("end"),undef,CX.'='.CXMX],
#
#    # del, ret
#    'EDEL',[KI("del"),undef,''],
#
#    'ERET',[KI("ret"),undef,''],

  );

# ---   *   ---   *   ---

sub generator {
  my $FH=shift;

  # KEYMAP[key_name]==scancode
  # we don't use this, nice to have maybe?
  my $T0="\nstatic const char KEYMAP[]={\n";

  # some more macros
  my $T1=''.

    "#ifndef NIHIL_FUNC\n".
    "#define NIHIL_FUNC\n".
    "typedef void(*nihil)(void);\n".
    "#endif\n".

    "#define IS_TAP(x) ((".KBD."[(x)]&0b001)>>0)\n".
    "#define IS_HEL(x) ((".KBD."[(x)]&0b010)>>1)\n".
    "#define IS_REL(x) ((".KBD."[(x)]&0b100)>>2)\n".

    "\nenum {\n";

  # keydown events
  my $T2="void keyset(char key,char rel) {\n";
  $T2.=" if(!rel) {\n  switch(key) {\n\n";

  # keyup events
  my $T3=" } else {\n  switch(key) {\n\n";

  # keyheld functions
  my $T4="void keyskip(void) {;};\n";

  # ^an array of pointers to them
  my $T5="static const nihil K_HEL_FUNCS[]={\n".
    "keyskip,\n"

  ;

# ---   *   ---   *   ---

  # iter through the map
  my $i=0;while(@KEYMAP) {
    my $name=shift @KEYMAP;
    my $data=shift @KEYMAP;

    # unpack array reference
    my (
      $kcode,
      $onDown,
      $onUp,
      $onHeld,

    )=@{ $data };

# ---   *   ---   *   ---

    # add items to enum,array couple
    $T0.="$kcode,\n";
    $T1.="K_$name,\n";

# ---   *   ---   *   ---

    # ontap table

    $T2.="   case $kcode:\n";

    $T2.=

      "   ".KBD."[K_$name]|=3;\n".

#      "   ".KBD."[K_$name]|=2*((".
#        KBD."[K_$name]&1));\n".
#
#      "   ".KBD."[K_$name]&=~1;\n".
#      "   ".KBD."[K_$name]|=1*(!(".
#        KBD."[K_$name]&2));\n".

      "   if(".KBD."[K_$name]&1) {\n".
      "    $onDown;\n  };\n".

      "   break;\n\n";

# ---   *   ---   *   ---

    # onrel table

    $T3.="  case $kcode:\n  $onUp;\n";

    $T3.=
      "   ".KBD."[K_$name]&=~3;\n".
      "   ".KBD."[K_$name]|=4;break;\n";

# ---   *   ---   *   ---

    # onhel table

    $T4.="void K_HEL_FUNC_$name(void) {\n".
      " $onHeld;\n};\n\n";

    $T5.="K_HEL_FUNC_$name,\n";

    $i++;

  };

# ---   *   ---   *   ---

  # get rid of the last comma and close lists
  $T0=substr $T0,0,(length $T0)-2;
  $T0.="\n};\n\n";

  # end the enum with a num_items
  $T1.="K_COUNT\n};\n\n";

  # end switch0;end switch1,end if, end function
  $T2.="\n   default:break;\n  };\n\n";
  $T3.="\n   default:break;\n  };\n };\n};\n\n";

  # end function table
  $T5=substr $T5,0,(length $T5)-2;
  $T5.="\n};\n\n";

  # ^add caller def
  $T5.="void keychk(void) {\n".
    " for(int x=0;x<K_COUNT;x++) {\n".
    "  K_HEL_FUNCS[(x+1)*IS_HEL(x)]();\n".
    " };\n".
    "};\n\n"

  ;

# ---   *   ---   *   ---

  # this bit is just to see the key names
  my $DEBUG_NAMES="static const char* KEY_NAMES[]={\n";
  my @lay=@{ $CACHE{-LAYOUT_I} };

  # make an array of human-readable ids
  # useful for debug prints
  while(@lay) {
    my $name=shift @lay;
    $DEBUG_NAMES.=(avt::dqwrap $name ).",\n";

  };$DEBUG_NAMES=substr(
      $DEBUG_NAMES,0,
      length $DEBUG_NAMES

  );$DEBUG_NAMES.="\n};\n\n";

  # write it all to file
  print $FH $T0.$T1.$T2.$T3.$T4.$T5.$DEBUG_NAMES;

};

# ---   *   ---   *   ---

my $root=avt::root $ENV{'ARPATH'};chdir $root;

avt::wrcboil_h(
  '/ce/',
  'keymap',
  \&generator,
  'IBN-3DILA'

);


# ---   *   ---   *   ---
1; # ret
