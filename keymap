#!/usr/bin/perl
# ---   *   ---   *   ---
# KEYMAP
# generates tables for
# key lookups, and such

# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit

# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

# deps
  use strict;
  use warnings;

  # change to install dir when we're done
  use lib $ENV{'ARPATH'}.'/avtomat/';
  use avt;

  my $root=avt::root $ENV{'ARPATH'};chdir $root;

# ---   *   ---   *   ---
# some macros

  use constant {
    STRUCT => "CE",

  };use constant {
    CURSOR => "${ \STRUCT }.cursor",
    KBD    => "${ \STRUCT }.kbd",
    WDIM   => "${ \STRUCT }.wsz.ws_",
    BUSY   => "${ \STRUCT }.evcnt",
    EVSTK  => "${ \STRUCT }.evstack",
    EVCNT  => "${ \STRUCT }.evstack_i",
    CTTY   => "${ \STRUCT }.ctty",

  };use constant {
    CY     => "${ \CURSOR }.y",
    CYMN   => '0',
    CYMX   => "${ \WDIM }row-1",

    CX     => "${ \CURSOR }.x",
    CXMN   => '0',
    CXMX   => "${ \WDIM }col-1",

  };

# ---   *   ---   *   ---
# global storage

  my %CACHE=(
    -LAYOUT   => 0,
    -LAYOUT_I => 0,

  );

# ---   *   ---   *   ---

# magic
sub parse_kbdlay {
  my $f=$ENV{'ARPATH'}.'/ce/kbdlay';
  my @lines=split "\n",`cat $f`;
  my %kbdlay;my $i=0;
  my @layi=();

  while(@lines) {
    my $line=shift @lines;
    if(!$line || (index $line,'#')==0) {
      next;

    };$line.=($line eq 'NON')
      ? "$i"
      : ''
      ;

    $kbdlay{$line}=$i;$i++;
    push @layi,$line;

  };$CACHE{-LAYOUT_I}=\@layi;
  return \%kbdlay;

};$CACHE{-LAYOUT}=parse_kbdlay();

# arg=keyname
# Key Index, a simple shorthand
sub KI {
  my $key_name=shift;
  return $CACHE{-LAYOUT}->{$key_name};

};

# ---   *   ---   *   ---

# parse *.k file into a list
sub rdkfile {

  my $fpath=shift;
  if(!(-e $fpath)) {
    print "Can't find $fpath";
    exit;

  };my $s=`cat $fpath`;
  my $tap=(split "onTap\n",$s)[1];
  $tap=(split "onHel\n",$tap)[0];

  my $hel=(split "onHel\n",$s)[1];
  $hel=(split "onRel\n",$hel)[0];

  my $rel=(split "onRel\n",$s)[1];

  for my $ev ($tap,$hel,$rel) {
    if((index $ev,'None')>-1) {$ev='';};
  };

  return ($tap,$rel,$hel);

};

# ---   *   ---   *   ---
# read glyph table

sub tifunc {
  my ($lc,$uc,$mr)=@_;

  for my $c($lc,$uc,$mr) {
    $c=sprintf "\\x%02X",ord($c);

  };

  my $s=<<"EOF"

  keycool();
  char table[4]="$lc$uc$mr";

  keyibs(table[
    (keyhel(K_LSHIFT))
   +(keyhel(K_RALT)<<1)

  ]);

EOF
; return $s;

};

sub rdti {

  my @table=split "\n",`cat ./ce/keys/ti`;
  my @map=();

  while(@table) {
    my $line=shift @table;
    if(!$line) {next;};

    my (
      $name,
      $lc,$uc,$mr

    )=split ' ',$line;

    my $fullname='TI'.( uc $name );
    if($name eq 'space') {
      $lc=$uc=$mr=' ';

    };

    my $onDown=tifunc($lc,$uc,$mr);

    push @map,$fullname;
    push @map,[KI($name),
      $onDown,'',''

    ]; #'K_TAP_FUNC_'.$fullname.'();'

  };return @map;

};

# ---   *   ---   *   ---
# base table

  # 'key_name'=>[scancode,onDown,onUp,onHeld]

  my @KEYMAP=(

    # quick exit for testing
    'ESC' ,[
      KI('escape'),
      '','dpycl();dumpf();exit(0);','',

    ],

    # modifiers
    'LALT',[KI('LAlt'),'','',''],
    'RALT',[KI('RAlt'),'','',''],
    'LSHIFT',[KI('LShift'),'','',''],

    # movement keys
    'AUP' ,[
      KI('up'),
      rdkfile('./ce/keys/up.k')

    ],

    'ADWN',[
      KI('down'),
      rdkfile('./ce/keys/down.k')

    ],

    'ARGT',[
      KI('right'),
      rdkfile('./ce/keys/right.k')

    ],

    'ALFT',[
      KI('left'),
      rdkfile('./ce/keys/left.k')

    ],

#    # re/av,beg/end
#    'GPRV',[KI("re"),undef,CY.'='.CYMN],
#
#    'GNXT',[KI("av"),undef,CY.'='.CYMX],
#
#    'GBEG',[KI("home"),undef,CX.'='.CXMN],
#
#    'GEND',[KI("end"),undef,CX.'='.CXMX],
#
#    # del, ret
#    'EDEL',[KI("del"),undef,''],
#
    'ERET',[
      KI("ret"),
      rdkfile('./ce/keys/ret.k')

    ],

  );my $NON_TI=int((@KEYMAP)/2);
  push @KEYMAP,rdti;

# ---   *   ---   *   ---

sub keymap_generator {
  my $FH=shift;

  my @lists=();{

    my $item;

    # KEYMAP[key_name]==scancode
    # we don't use this, nice to have maybe?
    $item=avt::clist([0,'arr:char','KEYMAP','']);

    push @lists,$item;

    $item=avt::clist([0,'enum:K_COUNT','','']);
    push @lists,$item;

  };

# ---   *   ---   *   ---
# layout -> keymap lookup table

  my $CODE_TO_KEY='';{

    # get (used_indices:used_values)
    my @used_keys=();{
      for(my $i=1;$i<@KEYMAP;$i+=2) {
        push @used_keys,$KEYMAP[$i]->[0];

      };
    };my $list=avt::clist(
      [0,'arr:char','KEYLAY','']

    );

# ---   *   ---   *   ---

    # match layout indices to used ones
    my @lay=@{ $CACHE{-LAYOUT_I} };
    my $i=0;while(@lay) {
      my $kname=shift @lay;
      my $kcode=KI($kname);

      $list->[2]=0;

      # cant think of a smart way to do it
      for(my $j=0;$j<@used_keys;$j++) {
        if($used_keys[$j]==$kcode) {
          $list->[2]=$j+1;last;

        };
      };

      $list=avt::clist($list);

    };$list->[0]++;

    $list=avt::clist($list);
    $CODE_TO_KEY=$list->[3];

  };

# ---   *   ---   *   ---

  # iter through the map
  for(my $i=0;$i<@KEYMAP;$i+=2) {
    my $name=$KEYMAP[$i+0];
    my $data=$KEYMAP[$i+1];

    # unpack array reference
    my (
      $kcode,
      $onDown,
      $onUp,
      $onHeld,

    )=@{ $data };

# ---   *   ---   *   ---

    # populate lists
    { my @items=($kcode,"K_$name");
      for(my $j=0;$j<@lists;$j++) {
        $lists[$j]->[2]=$items[$j];
        $lists[$j]=avt::clist($lists[$j]);

      };
    };

  };

# ---   *   ---   *   ---

  my $result=''.
    "#define NON_TI $NON_TI\n".
    $CODE_TO_KEY;

  # close lists
  for(my $j=0;$j<@lists;$j++) {
    $lists[$j]->[0]++;
    $lists[$j]=avt::clist($lists[$j]);

    $result.=$lists[$j]->[3];

  };

  # write it all to file
  print $FH $result;

};

# ---   *   ---   *   ---

avt::wrcboil_h(
  '/ce/',
  'keymap',
  \&keymap_generator,
  'IBN-3DILA'

);


# ---   *   ---   *   ---

# auxiliary file
sub keycalls_generator {

  my $FH=shift;

  my $result='';
  my $evtable="void K_FUNCS_LOAD(void) {\n";

  my $evfuncs=['void:void','','',''];

  # iter through the map
  for(my $i=0;$i<@KEYMAP;$i+=2) {
    my $name=$KEYMAP[$i+0];
    my $data=$KEYMAP[$i+1];

    # unpack array reference
    my (
      $kcode,
      $onDown,
      $onUp,
      $onHeld,

    )=@{ $data };

# ---   *   ---   *   ---

    # go through the code
    { my @helper=(
        $onDown,'TAP',
        $onHeld,'HEL',
        $onUp  ,'REL',

      );my $j=0;while(@helper) {
        my $code=shift @helper;
        my $suff=shift @helper;

        # populate callback arrays
        my $funcname=(!$code)
          ? "keyskip"
          : "\&K_$suff"."_FUNC_$name"
          ;

        $evtable.="keycall(K_$name,$j,$funcname);\n";
        $j++;

# ---   *   ---   *   ---

        # skip empty or make definition
        if(!$code) {next;};

        $evfuncs->[1]="K_$suff"."_FUNC_$name";
        $evfuncs->[2]=$code;

        $evfuncs=avt::cfunc($evfuncs);


      };
    };
  };

# ---   *   ---   *   ---

  $result.=( $evfuncs->[3] ).$evtable."\n};\n";
  print $FH $result;

};

# ---   *   ---   *   ---

avt::wrcboil_h(
  '/ce/',
  'keycalls',
  \&keycalls_generator,
  'IBN-3DILA'

);

# ---   *   ---   *   ---
1; # ret
