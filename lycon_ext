#!/usr/bin/perl
# ---   *   ---   *   ---
#:CUT;>
# ---   *   ---   *   ---
# LYCON_EXT
# Extends lycon with classes
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

sub nope {;};
1; # ret

package lycon::clk;
  use strict;
  use warnings;

  use lib $ENV{'ARPATH'}.'/lib/';
  use avt;

# ---   *   ---   *   ---
# global state

my %CLK=(

  -FLEN=>0x6000,

  -VSZ=>8,
  -VIS=>

    "\x{01A9}\x{01AA}\x{01AB}\x{01AC}".
    "\x{01AD}\x{01AE}\x{01AF}\x{01B0}",

);

# ---   *   ---   *   ---
# get/set

sub flen {
  return avt::getset(
    \%CLK,-FLEN,shift

  );
};

sub vsz {
  return avt::getset(
    \%CLK,-VSZ,shift

  );
};

sub vis {
  return avt::getset(
    \%CLK,-VIS,shift

  );
};


# ---   *   ---   *   ---
# constructor

sub nit {

  flen(shift);
  vis(shift);
  vsz(shift);

  lycon::clknt(flen,vis,vsz);

};

# ---   *   ---   *   ---

package lycon::kbd;
  use strict;
  use warnings;

  use lib $ENV{'ARPATH'}.'/lib/';

  use lang;

  use avt;
  use genks;

# ---   *   ---   *   ---
# global state

my @KEYS=();
my %KEYS=();
my @SWKEYS=();

# ---   *   ---   *   ---
# getters

sub HASKEY {

  my $key=shift;

  if(!exists $KEYS{$key}) {
    printf "No key $key was registered at nit\n";
    return;

  };
};

# ---   *   ---   *   ---
# in: user-given name,keylay name,code reference
# add a key to the event list

sub DEFINE {

  my $key=shift;
  my $id=shift;

  my $onTap=shift;
  my $onHel=shift;
  my $onRel=shift;

  push @KEYS,$key;
  push @KEYS,[$id,$onTap,$onHel,$onRel];

# ---   *   ---   *   ---
# in:user-given name, callbacks list
# swap out callbacks on this key

};sub REDEF {

  my $key=shift;
  HASKEY($key);

  my $onTap=shift;
  my $onHel=shift;
  my $onRel=shift;

  my $idex=($KEYS{$key}*2)+1;

  $KEYS[$idex]->[1]=($onTap)
    ? $onTap : $KEYS[$idex]->[1];

  $KEYS[$idex]->[2]=($onHel)
    ? $onHel : $KEYS[$idex]->[2];

  $KEYS[$idex]->[3]=($onRel)
    ? $onRel : $KEYS[$idex]->[3];

# ---   *   ---   *   ---
# in: user-given name
# store callbacks on this key

};sub SVDEF {

  my $key=shift;
  HASKEY($key);

  my $idex=($KEYS{$key}*2)+1;

  return [

    $KEYS[$idex]->[1],
    $KEYS[$idex]->[2],
    $KEYS[$idex]->[3],

  ];

# ---   *   ---   *   ---
# ^restore saved callbacks

};sub LDDEF {

  my $key=shift;
  my $calls=shift;
  HASKEY($key);

  my $idex=($KEYS{$key}*2)+1;

  $KEYS[$idex]->[1]=$calls->[0];
  $KEYS[$idex]->[2]=$calls->[1];
  $KEYS[$idex]->[3]=$calls->[2];

};

# ---   *   ---   *   ---
# register events

sub nit {

  %KEYS=@KEYS;
  lycon::keynt(genks::pl_keymap(\@KEYS,\%KEYS));

  ldkeys();

};

# ---   *   ---   *   ---
# load defined callbacks

sub ldkeys {

  for(my $x=1;$x<@KEYS;$x+=2) {

    my $name=$KEYS[$x-1];
    my @ar=@{$KEYS[$x]}[1..3];

    my $i=0;

# ---   *   ---   *   ---

    # convert perl subs to closures
    # ie, callable from C
    for my $ev(@ar) {

      if(lang::is_code($ev)) {
        my $cev=lycon::ffi->closure($ev);
        $cev->sticky();

        lycon::keycall($KEYS{$name},$i,$cev);

      };$i++;

    };

  };
};

# ---   *   ---   *   ---

package lycon::dpy;
  use strict;
  use warnings;

# ---   *   ---   *   ---

sub beg {
  print "\e[0m\e[2J\e[0H\e[?25l";
  STDOUT->flush();

};

sub end {
  print "\e[0m\e[2J\e[0H\e[?25h";
  STDOUT->flush();

};

# ---   *   ---   *   ---

package lycon::loop;
  use strict;
  use warnings;

  # lame fwd decl
  my %LOOP=();

# ---   *   ---   *   ---
# shorthands

sub ALWAYS {return 1;};
sub NEVER {return 0;};

# ---   *   ---   *   ---
# flush out the draw buffer as-is
sub ascii {

  printf $LOOP{-DRAW_BUFF};
  STDOUT->flush();

  $LOOP{-DRAW_BUFF}='';

};

# ---   *   ---   *   ---
# global state

%LOOP=(


  -LOGI_PROC=>\&lycon::nope,
  -LOGI_ARGS=>[],

  -QUIT_PROC=>\&NEVER,

  -DRAW_PROC=>\&ascii,
  -DRAW_BUFF=>'',

  -BUSY=>0,

);

# ---   *   ---   *   ---
# getters

sub logic {
  return $LOOP{-LOGI_PROC}->(
    @{$LOOP{-LOGI_ARGS}}

  );
};

sub quit {return $LOOP{-QUIT_PROC}->();};
sub draw {return $LOOP{-DRAW_PROC}->();};

sub draw_update {
  return 0<length $LOOP{-DRAW_BUFF};

};sub dwbuff {$LOOP{-DRAW_BUFF}.=shift;};

# ---   *   ---   *   ---
# setters

sub set_logic {
  $LOOP{-LOGI_PROC}=shift;
  $LOOP{-LOGI_ARGS}=shift;

};

sub set_quit {$LOOP{-QUIT_PROC}=shift;};
sub set_draw {$LOOP{-DRAW_PROC}=shift;};
sub busy {return avt::getset(\%LOOP,-BUSY,shift);};

# ---   *   ---   *   ---
# execute the main loop

sub run {

  while(!quit) {

    busy(lycon::gtevcnt());

    if(draw_update) {
      (draw);

    };

    lycon::tick(busy);

    lycon::keyrd();
    lycon::keychk();

    (logic);

  };

};

# ---   *   ---   *   ---

package lycon::ctl;
  use strict;
  use warnings;

my %CTL=(
  -STACK=>[],

);sub STACK {return $CTL{-STACK};};

sub switch {

  my $logic=shift;
  my $args=shift;
  my $draw=shift;

  push @{STACK()},
    $LOOP{-LOGI_PROC},
    $LOOP{-LOGI_ARGS};

  push @{STACK()},$LOOP{-DRAW_PROC};

  lycon::loop::set_logic($logic);
  lycon::loop::set_draw($draw);

};sub ret {

  my $draw=pop @{STACK()};
  my $args=pop @{STACK()};
  my $logic=pop @{STACK()};

  lycon::loop::set_logic($logic,$args);
  lycon::loop::set_draw($draw);

};

# ---   *   ---   *   ---
1; # ret
